/*
*********************************************************************************************************
* File    : dram_init.c
* By      : Berg.Xing
* Date    : 2011-06-01
* Descript: dram for AW1623 chipset;
* Update  : date                auther      ver     notes
*           2011-06-01                  Berg        1.0     create file
*           2011-06-15      			Berg        1.1     change pad drive mode to dynamic mode0;
*															change to automatic IDDQ mode when entry into
*															self-refresh or power down for saving power
*           2011-07-01      			Berg        1.2     add mctl_disable_dll() function
*															add odt control bit and odt impendance
*															increase dram pll delay time
*           2011-07-27      			Berg        1.3     change pad to high speed mode and
*															select DQS passive window mode
*															tune port priority level
*			2011-08-05					Berg		1.4		change mctl_ddr3_reset() for different die
*			2011-09-16					Berg		1.5		disable dqs drfit compensation for low tempature
*********************************************************************************************************
*/
#include "dram_i.h"

typedef struct _boot_dram_para_t
{
    __u32           dram_baseaddr;
    __u32           dram_clk;
    __u32           dram_type;
    __u32           dram_rank_num;
    __u32           dram_chip_density;
    __u32           dram_io_width;
    __u32		    dram_bus_width;
    __u32           dram_cas;
    __u32           dram_zq;
    __u32           dram_odt_en;
    __u32 			dram_size;
    __u32           dram_tpr0;
    __u32           dram_tpr1;
    __u32           dram_tpr2;
    __u32           dram_tpr3;
    __u32           dram_tpr4;
    __u32           dram_tpr5;
    __u32 			dram_emr1;
    __u32           dram_emr2;
    __u32           dram_emr3;
}boot_dram_para_t;

/******************************************************************************/
/*                              file head of Boot                             */
/******************************************************************************/
typedef struct _Boot_file_head
{
	__u32  jump_instruction;   // one intruction jumping to real code
	__u8   magic[8];           // ="eGON.BT0" or "eGON.BT1",  not C-style string.
	__u32  check_sum;          // generated by PC
	__u32  length;             // generated by PC
	__u32  pub_head_size;      // the size of boot_file_head_t
	__u8   pub_head_vsn[4];    // the version of boot_file_head_t
	__u8   file_head_vsn[4];   // the version of boot0_file_head_t or boot1_file_head_t
	__u8   Boot_vsn[4];        // Boot version
	__u8   eGON_vsn[4];        // eGON version
	__u8   platform[8];        // platform information
}boot_file_head_t;


typedef struct _boot_para_info_t
{
    __u8   blkmagic[16];          // "ePDK-Magic-Block", not C-style string.
    __u8   magic[8];
    __u8   eGON_vsn[4];           // eGON version
	__u8   Boot_vsn[4];           // Boot version
    __u32  reserved[20];
}boot_para_info_t;

//通用的，和GPIO相关的数据结构
typedef struct _normal_gpio_cfg
{
    __u8      port;                       //端口号
    __u8      port_num;                   //端口内编号
    __s8      mul_sel;                    //功能编号
    __s8      pull;                       //电阻状态
    __s8      drv_level;                  //驱动驱动能力
    __s8      data;                       //输出电平
    __u8      reserved[2];                //保留位，保证对齐
}
normal_gpio_cfg;

/******************************************************************************/
/*                              file head of Boot0                            */
/******************************************************************************/
typedef struct _boot0_private_head_t
{
	__u32                       prvt_head_size;
	char                        prvt_head_vsn[4];       // the version of boot0_private_head_t
	boot_dram_para_t            dram_para;              // DRAM patameters for initialising dram. Original values is arbitrary,
	__s32						uart_port;              // UART控制器编号
	normal_gpio_cfg             uart_ctrl[2];           // UART控制器(调试打印口)数据信息
	__s32                       enable_jtag;            // 1 : enable,  0 : disable
    normal_gpio_cfg	            jtag_gpio[5];           // 保存JTAG的全部GPIO信息
    normal_gpio_cfg             storage_gpio[32];       // 存储设备 GPIO信息
    char                        storage_data[512 - sizeof(normal_gpio_cfg) * 32];      // 用户保留数据信息
    //boot_nand_connect_info_t    nand_connect_info;
}boot0_private_head_t;


typedef struct _boot0_file_head_t
{
	boot_file_head_t      boot_head;
	boot0_private_head_t  prvt_head;
}boot0_file_head_t;

typedef  boot_dram_para_t		__dram_para_t;

#define BOOT0_PRVT_HEAD_VERSION         "1230"    // X.X.XX
#define BOOT0_FILE_HEAD_VERSION         "1230"    // X.X.XX

#define BOOT0_VERSION                   "1230"    // X.X.XX

#define BOOT_PUB_HEAD_VERSION           "1100"    // X.X.XX
#define EGON_VERSION                    "1100"    // X.X.XX

#define SUNII_PLATFORM_VALUE           "SUNII"
#ifndef PLATFORM
#define PLATFORM                        SUNII_PLATFORM_VALUE
#endif

#define MASK_TOTAL                      0x80000000
#define DEFAULT_VALUE                   0x0
#define STAMP_VALUE                     0x5F0A6C39

#define   DDR3_USED

static boot_dram_para_t tmp = {
	0x40000000,
	360,
	3,
	2,
	2048,
	16,
	32,
	6,
	0x7b,
	0,
	1024,
	0x30926692,
	0x1090,
	0x1a0c8,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0
};

/*
*********************************************************************************************************
*                                   DRAM INIT
*
* Description: dram init function
*
* Arguments  : para     dram config parameter
*
*
* Returns    : result
*
* Note       :
*********************************************************************************************************
*/
void mctl_ddr3_reset(void)
{
    __u32 reg_val;
    __u32 i=0;

    mctl_write_w(TIMER_CPU_CFG_REG, 0);
    reg_val = mctl_read_w(TIMER_CPU_CFG_REG);
    reg_val >>=6;
    reg_val &=0x3;
    if(reg_val == 0)
    {
        reg_val = mctl_read_w(SDR_CR);
        reg_val &= ~(0x1<<12);
        mctl_write_w(SDR_CR, reg_val);
        standby_delay(0x100);
        reg_val = mctl_read_w(SDR_CR);
        reg_val |= (0x1<<12);
        mctl_write_w(SDR_CR, reg_val);
    }
    else
    {
        reg_val = mctl_read_w(SDR_CR);
        reg_val |= (0x1<<12);
        mctl_write_w(SDR_CR, reg_val);
        standby_delay(0x100);
        reg_val = mctl_read_w(SDR_CR);
        reg_val &= ~(0x1<<12);
        mctl_write_w(SDR_CR, reg_val);
    }
}

void mctl_set_drive(void)
{
    __u32 reg_val;

    reg_val = mctl_read_w(SDR_CR);
    reg_val |= (0x6<<12);
		reg_val |= 0xF00;
    reg_val &= ~0x3;
    mctl_write_w(SDR_CR, reg_val);
}

void mctl_itm_disable(void)
{
    __u32 reg_val = 0x0;

    reg_val = mctl_read_w(SDR_CCR);
    reg_val |= 0x1<<28;
    mctl_write_w(SDR_CCR, reg_val);
    standby_delay(0x100);
}

void mctl_itm_enable(void)
{
    __u32 reg_val = 0x0;

    reg_val = mctl_read_w(SDR_CCR);
    reg_val &= ~(0x1<<28);
    mctl_write_w(SDR_CCR, reg_val);
}

void mctl_enable_dll0(void)
{
    __u32 i = 0;

    mctl_write_w(SDR_DLLCR0, mctl_read_w(SDR_DLLCR0) & ~0x40000000 | 0x80000000);
	standby_delay(0x100);

    mctl_write_w(SDR_DLLCR0, mctl_read_w(SDR_DLLCR0) & ~0xC0000000);
	standby_delay(0x1000);

    mctl_write_w(SDR_DLLCR0, mctl_read_w(SDR_DLLCR0) & ~0x80000000 | 0x40000000);
    standby_delay(0x1000);
}

void mctl_enable_dllx(void)
{
    __u32 i = 0;

    for(i=1; i<5; i++)
    {
        mctl_write_w(SDR_DLLCR0+(i<<2), mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0x40000000 | 0x80000000);
    }

	standby_delay(0x100);

    for(i=1; i<5; i++)
    {
        mctl_write_w(SDR_DLLCR0+(i<<2), mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0xC0000000);
    }

	standby_delay(0x1000);

    for(i=1; i<5; i++)
    {
        mctl_write_w(SDR_DLLCR0+(i<<2), mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0x80000000 | 0x40000000);
    }
    standby_delay(0x1000);
}

void mctl_disable_dll(void)
{
	__u32 reg_val;

	reg_val = mctl_read_w(SDR_DLLCR0);
	reg_val &= ~(0x1<<30);
	reg_val |= 0x1U<<31;
	mctl_write_w(SDR_DLLCR0, reg_val);

	reg_val = mctl_read_w(SDR_DLLCR1);
	reg_val &= ~(0x1<<30);
	reg_val |= 0x1U<<31;
	mctl_write_w(SDR_DLLCR1, reg_val);

	reg_val = mctl_read_w(SDR_DLLCR2);
	reg_val &= ~(0x1<<30);
	reg_val |= 0x1U<<31;
	mctl_write_w(SDR_DLLCR2, reg_val);

	reg_val = mctl_read_w(SDR_DLLCR3);
	reg_val &= ~(0x1<<30);
	reg_val |= 0x1U<<31;
	mctl_write_w(SDR_DLLCR3, reg_val);

	reg_val = mctl_read_w(SDR_DLLCR4);
	reg_val &= ~(0x1<<30);
	reg_val |= 0x1U<<31;
	mctl_write_w(SDR_DLLCR4, reg_val);
}

__u32 hpcr_value[32] = {
    0x00000301,0x00000301,0x00000301,0x00000301,
    0x00000301,0x00000301,0x0,       0x0,
    	0x0,       0x0,       0x0,       0x0,
    0x0,       0x0,       0x0,       0x0,
			0x00001031,0x00001031,0x00000735,0x00001035,
			0x00001035,0x00000731,0x00001031,0x00000735,
			0x00001035,0x00001031,0x00000731,0x00001035,
			0x00001031,0x00000301,0x00000301,0x00000731,
};

void mctl_configure_hostport(void)
{
    __u32 i;

    for(i=0; i<32; i++)
    {
        mctl_write_w(SDR_HPCR + (i<<2), hpcr_value[i]);
    }
}

void mctl_setup_dram_clock(__u32 clk)
{
    __u32 i;
    __u32 reg_val;

    //setup DRAM PLL
    reg_val = mctl_read_w(DRAM_CCM_SDRAM_PLL_REG);
    reg_val &= ~0x3;
    reg_val |= 0x1;                     //m factor
    reg_val &= ~(0x3<<4);
    reg_val |= 0x1<<4;                  //k factor
    reg_val &= ~(0x1f<<8);
    reg_val |= (standby_uldiv((__u64)clk, 24)&0x1f)<<8;      //n factor
    reg_val &= ~(0x3<<16);
    reg_val |= 0x1<<16;                 //p factor
    reg_val &= ~(0x1<<29);                                         //PLL on
    reg_val |= (__u32)0x1<<31;          //PLL En
    mctl_write_w(DRAM_CCM_SDRAM_PLL_REG, reg_val);
    standby_delay(0x300000);
    reg_val = mctl_read_w(DRAM_CCM_SDRAM_PLL_REG);
	reg_val |= 0x1<<29;    //ddr out clk en
    mctl_write_w(DRAM_CCM_SDRAM_PLL_REG, reg_val);
	//standby_delay(0x100000);
	
    //reset GPS
    reg_val = mctl_read_w(DRAM_CCM_GPS_CLK_REG);
    reg_val &= ~0x3;
    mctl_write_w(DRAM_CCM_GPS_CLK_REG, reg_val);
    reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
    reg_val |= (0x1<<26);
    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);
    standby_delay(0x20);
    reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
    reg_val &= ~(0x1<<26);
    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);

    //open DRAMC AHB clock
    //close it first
    reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
    reg_val &= ~(0x1<<14);
    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);
	standby_delay(0x1000);

    //then open it
    reg_val |= 0x1<<14;
    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);
	standby_delay(0x1000);
}

__s32 DRAMC_init(__dram_para_t *para)
{
    __u32 i;
    __u32 reg_val;
    __s32 ret_val;

    //check input dram parameter structure
    if(!para)
    {
        //dram parameter is invalid
        return -1;
    }
    save_mem_status(SUSPEND_START + 0x110);
    //setup DRAM relative clock
    mctl_setup_dram_clock(para->dram_clk);

    //reset external DRAM
    save_mem_status(SUSPEND_START + 0x111);
    mctl_ddr3_reset();
    mctl_set_drive();

    //dram clock off
    save_mem_status(SUSPEND_START + 0x112);
    DRAMC_clock_output_en(0);

    //select dram controller 1
    save_mem_status(SUSPEND_START + 0x113);
    mctl_write_w(SDR_SCSR, 0x16237495);

    save_mem_status(SUSPEND_START + 0x114);
    mctl_itm_disable();
    save_mem_status(SUSPEND_START + 0x115);
    mctl_enable_dll0();

    //configure external DRAM
    reg_val = 0;
    if(para->dram_type == 3)
        reg_val |= 0x1;
    reg_val |= (para->dram_io_width>>3) <<1;

    if(para->dram_chip_density == 256)
        reg_val |= 0x0<<3;
    else if(para->dram_chip_density == 512)
        reg_val |= 0x1<<3;
    else if(para->dram_chip_density == 1024)
        reg_val |= 0x2<<3;
    else if(para->dram_chip_density == 2048)
        reg_val |= 0x3<<3;
    else if(para->dram_chip_density == 4096)
        reg_val |= 0x4<<3;
    else if(para->dram_chip_density == 8192)
        reg_val |= 0x5<<3;
    else
        reg_val |= 0x0<<3;
    reg_val |= ((para->dram_bus_width>>3) - 1)<<6;
    reg_val |= (para->dram_rank_num -1)<<10;
    reg_val |= 0x1<<12;
    reg_val |= ((0x1)&0x3)<<13;
    mctl_write_w(SDR_DCR, reg_val);

    //dram clock on
    save_mem_status(SUSPEND_START + 0x116);
    DRAMC_clock_output_en(1);
    save_mem_status(SUSPEND_START + 0x117);
standby_delay(0x10);
    while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};

		mctl_enable_dllx();

		//set odt impendance divide ratio
		reg_val = mctl_read_w(SDR_ZQCR0);
		reg_val &= ~(0xff<<20);
		reg_val |= ((para->dram_zq)&0xff)<<20;
		mctl_write_w(SDR_ZQCR0, reg_val);

		//set I/O configure register
		reg_val = 0x00cc0000;
		reg_val |= (para->dram_odt_en)&0x3;
		reg_val |= ((para->dram_odt_en)&0x3)<<30;
		mctl_write_w(SDR_IOCR, reg_val);

		//set refresh period
		save_mem_status(SUSPEND_START + 0x118);
    DRAMC_set_autorefresh_cycle(para->dram_clk);

    //set timing parameters
    mctl_write_w(SDR_TPR0, para->dram_tpr0);
    mctl_write_w(SDR_TPR1, para->dram_tpr1);
    mctl_write_w(SDR_TPR2, para->dram_tpr2);

    //set mode register
    if(para->dram_type==3)                  //ddr3
    {
        reg_val = 0x0;
        reg_val |= (para->dram_cas - 4)<<4;
        reg_val |= 0x5<<9;
    }
    else if(para->dram_type==2)             //ddr2
    {
        reg_val = 0x2;
        reg_val |= para->dram_cas<<4;
        reg_val |= 0x5<<9;
    }
    mctl_write_w(SDR_MR, reg_val);

    reg_val = 0x0;
    mctl_write_w(SDR_EMR, para->dram_emr1);
    reg_val = 0x0;
		mctl_write_w(SDR_EMR2, para->dram_emr2);
    reg_val = 0x0;
		mctl_write_w(SDR_EMR3, para->dram_emr3);

	//set DQS window mode
	reg_val = mctl_read_w(SDR_CCR);
	reg_val |= 0x1U<<14;
	reg_val &= ~(0x1U<<17);
	mctl_write_w(SDR_CCR, reg_val);

    //initial external DRAM
    reg_val = mctl_read_w(SDR_CCR);
    reg_val |= 0x1U<<31;
    mctl_write_w(SDR_CCR, reg_val);

    while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};

    //scan read pipe value
    mctl_itm_enable();
    save_mem_status(SUSPEND_START + 0x119);
    ret_val = DRAMC_scan_readpipe();

    if(ret_val < 0)
    {
        return 0;
    }
    //configure all host port
    save_mem_status(SUSPEND_START + 0x11a);
    mctl_configure_hostport();

    return DRAMC_get_dram_size();
}

/*
*********************************************************************************************************
*                                   DRAM EXIT
*
* Description: dram exit;
*
* Arguments  : none;
*
* Returns    : result;
*
* Note       :
*********************************************************************************************************
*/
__s32 DRAMC_exit(void)
{
    return 0;
}

/*
*********************************************************************************************************
*                                   CHECK DDR READPIPE
*
* Description: check ddr readpipe;
*
* Arguments  : none
*
* Returns    : result, 0:fail, 1:success;
*
* Note       :
*********************************************************************************************************
*/
__s32 DRAMC_scan_readpipe(void)
{
    __u32 reg_val;

    //data training trigger
    reg_val = mctl_read_w(SDR_CCR);
    reg_val |= 0x1<<30;
    mctl_write_w(SDR_CCR, reg_val);

    //check whether data training process is end
    while(mctl_read_w(SDR_CCR) & (0x1<<30)) {};

    //check data training result
    reg_val = mctl_read_w(SDR_CSR);
    if(reg_val & (0x1<<20))
    {
        return -1;
    }

    return (0);
}


/*
*********************************************************************************************************
*                                   DRAM SCAN READ PIPE
*
* Description: dram scan read pipe
*
* Arguments  : none
*
* Returns    : result, 0:fail, 1:success;
*
* Note       :
*********************************************************************************************************
*/


/*
*********************************************************************************************************
*                                   DRAM CLOCK CONTROL
*
* Description: dram get clock
*
* Arguments  : on   dram clock output (0: disable, 1: enable)
*
* Returns    : none
*
* Note       :
*********************************************************************************************************
*/
void DRAMC_clock_output_en(__u32 on)
{
    __u32 reg_val;

    reg_val = mctl_read_w(DRAM_CCM_SDRAM_CLK_REG);

    if(on)
        reg_val |= 0x1<<15;
    else
        reg_val &= ~(0x1<<15);

    mctl_write_w(DRAM_CCM_SDRAM_CLK_REG, reg_val);
}
/*
*********************************************************************************************************
* Description: Set autorefresh cycle
*
* Arguments  : clock value in MHz unit
*
* Returns    : none
*
* Note       :
*********************************************************************************************************
*/
void DRAMC_set_autorefresh_cycle(__u32 clk)
{
    __u32 reg_val;
    __u32 dram_size;
    __u32 tmp_val;

    dram_size = mctl_read_w(SDR_DCR);
    dram_size >>=3;
    dram_size &= 0x7;

    if(clk < 600)
    {
        if(dram_size<=0x2)
            tmp_val = (131*clk)>>10;
        else
            tmp_val = (336*clk)>>10;
        reg_val = tmp_val;
        tmp_val = (7987*clk)>>10;
        tmp_val = tmp_val*9 - 200;
        reg_val |= tmp_val<<8;
        reg_val |= 0x8<<24;
        mctl_write_w(SDR_DRR, reg_val);
    }
    else
    {
        mctl_write_w(SDR_DRR, 0x0);
    }
}


/*
**********************************************************************************************************************
*                                               GET DRAM SIZE
*
* Description: Get DRAM Size in MB unit;
*
* Arguments  : None
*
* Returns    : 32/64/128
*
* Notes      :
*
**********************************************************************************************************************
*/
__u32 DRAMC_get_dram_size(void)
{
    __u32 reg_val;
    __u32 dram_size;
    __u32 chip_den;

    reg_val = mctl_read_w(SDR_DCR);
    chip_den = (reg_val>>3)&0x7;
    if(chip_den == 0)
        dram_size = 32;
    else if(chip_den == 1)
        dram_size = 64;
    else if(chip_den == 2)
        dram_size = 128;
    else if(chip_den == 3)
        dram_size = 256;
    else if(chip_den == 4)
        dram_size = 512;
    else
        dram_size = 1024;

    if( ((reg_val>>1)&0x3) == 0x1)
        dram_size<<=1;
    if( ((reg_val>>6)&0x7) == 0x3)
        dram_size<<=1;
    if( ((reg_val>>10)&0x3) == 0x1)
        dram_size<<=1;

    return dram_size;
}

void   get_boot0_dram_para( boot_dram_para_t *boot0_dram_para_p )
{
	standby_memcpy( (void *)boot0_dram_para_p, (void *)&(tmp), sizeof(boot_dram_para_t) );
	//memcpy( boot0_dram_para_p, &(tmp), sizeof(boot_dram_para_t) );
	return;
}

__s32 dram_init(void)
{
    /* do nothing for dram init */
    return 0;
}
__s32 init_DRAM(void)
{
	__u32 i;
	__s32 ret_val;
	boot_dram_para_t  boot0_para;

	get_boot0_dram_para( &boot0_para );
	if(boot0_para.dram_clk > 2000)
	{
		boot0_para.dram_clk = standby_uldiv(boot0_para.dram_clk, 1000000);
		//boot0_para.dram_clk /= 1000000;
	}

	ret_val = 0;
	i = 0;
	save_mem_status(SUSPEND_START + 0x10);
	while( (ret_val == 0) && (i<4) )
	{
		ret_val = DRAMC_init( &boot0_para );
		i++;
	}
	save_mem_status(SUSPEND_START + 0x11);
	return ret_val;
}

__s32 dram_exit(void)
{
    return DRAMC_exit();
}

__s32 dram_get_size(void)
{
    return DRAMC_get_dram_size();
}

void dram_set_clock(int clk)
{
    return mctl_setup_dram_clock(clk);
}

void dram_set_drive(void)
{
    mctl_set_drive();
}

void dram_set_autorefresh_cycle(__u32 clk)
{
    DRAMC_set_autorefresh_cycle(clk);
}

__s32 dram_scan_readpipe(void)
{
    return DRAMC_scan_readpipe();
}

